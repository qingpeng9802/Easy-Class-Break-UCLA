# 查询信息预处理
## 信息提取
* 根据myUCLA网站DOM架构提取信息
`extractBoxClasses()`:  
通过`div.planneritembox`提取课程表信息，使用排列好的课程次序，避免使用算法计算课程间的前后关系  
`extractPlanClasses()`:  
通过`td.section-header a`提取单个课程信息，主要是课程id。通过分析链接获取课程名称和类型，此处采用根据关键字获取信息而不是采用硬编码索引来确保鲁棒性
* `mapID2BoxClasses()`  
通过课程名称和类型一一对应关系映射单个课程信息到课程表中的课中
* `time2Min()`  
将时间字符串统一转换成以从一天开始的分钟值方便后续计算差值  
## 计算课间时间
* 根据课程表位置关系确定课程前后关系，附加下节课的位置到本节课的信息  
* 根据课程结束时间和开始时间计算课间时间
## 构造并发送地址对  
* `requestDistance()`:  
严格保证（伪断言）地址对数和课程表中数量相同来保证后续添加信息节点的位置的正确  
发送地址对到`background.js`  
此处不先查询地址在地址列表的位置，模拟使用Google Maps API的行为，即使用地址对查询时间和路程的逻辑，将查询逻辑交给`background.js`处理  

# 信息交换 `content_script.js`<->`background.js`
## `content_script.js`
* 通过`chrome.runtime.sendMessage()`发送json信息到`background.js`  
* 通过`chrome.runtime.onMessage.addListener()`侦听来自`background.js`的信息  
## `background.js`  
* 通过`chrome.runtime.onMessage.addListener()`侦听来自`content_script.js`的信息  
* 通过`chrome.tabs.sendMessage()`发送json信息到指定的tab  

# 本地查询地址对的时间和距离  
## 距离矩阵的构造  
* UCLA有95个官方地址，但其中不是每个地址都被用作教室。先提取课程表存档，检查95个地址是否存在，剔除不存在的地址，留下60个教室地址  
* 分批（防止XMLHTTP请求过多浏览器不能处理）发送到Google Maps API获取时间距离  
* 异步获取的结果使用Python构造成距离矩阵并储存为json文件（一个三维数组）  
## 查询距离矩阵  
* 侦听到`content_script.js`信息后，回调`requestData()`，`requestData()`fetch`distanceMat.json`后回调`getDuaDis`
* `getDuaDis()`调用`findIndexofFullList()`，`findIndexofFullList()`通过字符串包含关系确定地址的匹配，避免了地址对中地址的预处理
* 查询`distanceMat.json`中的数据，通过`chrome.tabs.sendMessage()`发回`content_script.js`  

# 处理和显示结果  
## 处理结果  
* 附加每个结果到课程信息，同时根据`threshold`检查课间是否充足，不充足则`hurry=1`且`showInfoButton()`
* `showInfoButton()`获取自己的ID和下一节课的ID，遍历单条课程信息，找到对应的课程位置盒子，插入信息按钮和信息框  
## 显示结果  
* 插入信息框的时候，信息框会使得盒子的大小发生改变，即使得盒子变大。为了解决这个问题，外部套入一个`infotab`框，锁定框的大小使得盒子不会由于信息框而变大。信息框采用`board-box`来使得内容能够大于锁定框的大小
* 鼠标移过显示隐藏信息框的逻辑由`content_script.css`实现（信息框元素在按钮元素之后）

# Popup  
## `popup.html`  
在`.slidercontainer`中，加入一个`ul`，第一`li`是标题和重置按钮，第二`li`是范围条和范围框，最后`ul`外加入最小值和最大值
## `popup.js`  
为了满足Content Security Policy (CSP)，在
```javascript
document.addEventListener('DOMContentLoaded', function () {}
```
中
* 绑定元素和事件
* `main()`在其中初始化样式，避免使用`unsafe_inline`
### `main()`  
绑定范围条、范围框和`chrome.storage.sync`的值，通过将`threshold`值保存在`chrome.storage.sync`中来保证插件的值能持久化保存。`threshold`值通过判断是否已有用户输入而决定，有用户输入使用用户输入，没有默认为2
## `popup.css`  
范围条的Material Design通过`-webkit-slider-thumb`和`-webkit-slider-runnable-track`实现，可能会影响可移植性
